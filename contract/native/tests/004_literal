@test(numeric_value)
@run(test.test)
contract test {
    byte b1 = 0;
    byte b2 = 'A';
    byte b3 = 0xff;
    byte b4 = ' ';

    int8 i1 = +127;
    int8 i2 = -0x80;

    int16 i3 = +32767;
    int16 i4 = -0x8000;

    int32 i5 = +0x80000000 - 1;
    int32 i6 = -2147483648;

    int64 i7 = 9223372036854775807;
    int64 i8 = -0x8000000000000000;

    int256 i9 = 170141183460469231731687303715884105727;
    int256 i10 = -170141183460469231731687303715884105728;

    int i, j = 1, 0;

    test() {
        pragma assert(b1 == 0);
        pragma assert(b2 == 65);
        pragma assert(b3 == 255);
        pragma assert(b4 == 32);

        pragma assert(i1 == 127);
        pragma assert(i2 == -128);

        pragma assert(i3 == 32767);
        pragma assert(i4 == -32768);

        pragma assert(i5 == 2147483647);
        pragma assert(i6 == -2147483648);

        pragma assert(i7 == 9223372036854775807);
        pragma assert(i8 == -9223372036854775808);

        pragma assert(i9 == 170141183460469231731687303715884105727);
        pragma assert(i10 == -170141183460469231731687303715884105728);

        pragma assert(i == 1);
        pragma assert(j == 0);
    }
}

@test(mismatched_primitive_type)
@error(ERROR_MISMATCHED_TYPE,2)
contract test {
    int i = "1";
    string s = 1;
}

@test(numeric_overflow)
@error(ERROR_NUMERIC_OVERFLOW,12)
contract test {
    byte b1 = -1;
    byte b2 = 256;

    int8 i1 = -129;
    int8 i2 = 128;

    int16 i3 = -32769;
    int16 i4 = 32768;

    int32 i5 = -2147483649;
    int32 i6 = 2147483648;

    int64 i7 = -9223372036854775809;
    int64 i8 = 9223372036854775808;

    int256 i9 = -57896044618658097711785492504343953926634992332820282019728792003956564819969;
    int256 i10 = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
}

@test(string_value)
@run(test.test)
contract test {
    string v1 = "";
    string v2 = "literal";
    string v3 = "literal \"include quotation\"";
    string v4 = "literal /* with */ // comments";

    test() {
        pragma assert(v1 == "");
        pragma assert(v2 == "literal");
        pragma assert(v3 == "literal \"include quotation\"");
        pragma assert(v4 == "literal /* with */ // comments");

        string v = "earth";

        pragma assert(v[0] == 'e');
        pragma assert(v[1] == 'a');
        pragma assert(v[2] == 'r');
        pragma assert(v[3] == 't');
        pragma assert(v[4] == 'h');
    }
}

@test(unterminated_string)
@error(ERROR_UNTERMINATED_STRING)
contract test {
    string v = "unterminated string\";
}

@test(escaped_string)
@run(test.test)
contract test {
    string v1 = "\0";
    string v2 = "hello\nworld";

    test() {
        pragma assert(v1 == "");

        pragma assert(v2[0] == 'h');
        pragma assert(v2[1] == 'e');
        pragma assert(v2[2] == 'l');
        pragma assert(v2[3] == 'l');
        pragma assert(v2[4] == 'o');
        pragma assert(v2[5] == '\n');
        pragma assert(v2[6] == 'w');
        pragma assert(v2[7] == 'o');
        pragma assert(v2[8] == 'r');
        pragma assert(v2[9] == 'l');
        pragma assert(v2[10] == 'd');
    }
}

@test(predefined_constant)
@run(test.test)
contract test {
    bool b1 = true;
    bool b2 = false;
    string s = null;
    map(int, string) m = null;

    test() {
        pragma assert(b1 == true);
        pragma assert(b2 == false);
        pragma assert(s == null);
        pragma assert(m == null);
    }
}

@test(array_initializer)
@run(test.test)
contract test {
    bool b1[2] = new { true, false };
    byte b2[2] = new { 0xa, '%' };

    int8 i1[3] = new { -1, 0, 1, };
    int16 i2[1], i3[2] = new { 1024 }, new { 0x0000, 0xffff };

    int i4[1 + 1] = new { 1, 2 };
    int i5[1 * 3 - 1] = new { 3, 4 };

    int i6[2][2] = new { { 1, 2 }, { 3, 4 } };
    int i7[] = new { 4, 5, 6 };

    test() {
        pragma assert(b1[0] == true);
        pragma assert(b1[1] == false);

        pragma assert(b2[0] == 10);
        pragma assert(b2[1] == 37);

        pragma assert(i1[0] == -1);
        pragma assert(i1[1] == 0);
        pragma assert(i1[2] == 1);

        pragma assert(i2[0] == 1024);

        pragma assert(i3[0] == 0);
        pragma assert(i3[1] == -1);

        pragma assert(i4[0] == 1);
        pragma assert(i4[1] == 2);

        pragma assert(i5[0] == 3);
        pragma assert(i5[1] == 4);

        pragma assert(i6[0][0] == 1);
        pragma assert(i6[0][1] == 2);
        pragma assert(i6[1][0] == 3);
        pragma assert(i6[1][1] == 4);

        pragma assert(i7[0] == 4);
        pragma assert(i7[1] == 5);
        pragma assert(i7[2] == 6);

        int64 i8[][] = new { { 44, 28, 41 }, { 5, 9, 14 } };

        pragma assert(i8[0][0] == 44);
        pragma assert(i8[0][1] == 28);
        pragma assert(i8[0][2] == 41);
        pragma assert(i8[1][0] == 5);
        pragma assert(i8[1][1] == 9);
        pragma assert(i8[1][2] == 14);

        string s[3] = new { "a", "b", "c" };

        pragma assert(s[0] == "a");
        pragma assert(s[1] == "b");
        pragma assert(s[2] == "c");
    }
}

@test(empty_initializer)
@error(ERROR_SYNTAX)
contract test {
    int i[1] = new { };
}

@test(non_array_initializer)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i = new { 1, 2 };
}

@test(invalid_array_brace)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i[] = new { { 1, 2, 3 } };
}

@test(mismatched_element_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i[2][2] = new { { 1, 1 }, { 2, "2" } };
}

@test(mismatched_element_count)
@error(ERROR_MISMATCHED_COUNT,4)
contract test {
    int i[1] = new { 1, 2 };
    int j[2] = new { 1 };
    int k[3][2] = new { { 1, 2 }, { 3 } };
    int l[3][2] = new { { 1, 2 }, { 3, 4, 5 } };
}

@test(array_allocator)
@run(test.test)
contract test {
    bool b[] = new bool[1];
    int64 i[] = new int64[2];
    string s[] = new string[4];

    test() {
        pragma assert(b.size == 1);
        pragma assert(b[0] == false);
        pragma assert(i.size == 2);
        pragma assert(i[1] == 0);
        pragma assert(s.size == 4);
        pragma assert(s[1] == "");
        pragma assert(s[3] == null);

        int16 v1[] = new int16[2];

        pragma assert(v1.size == 2);
        pragma assert(v1[1] == 0);

        int32 v2[][] = new int32[2][2];

        pragma assert(v2.size == 2);
        pragma assert(v2[0].size == 2);
        pragma assert(v2[1].size == 2);
        pragma assert(v2[1][1] == 0);

        int64 v3[][] = new int64[2][4];

        pragma assert(v3.size == 2);
        pragma assert(v3[0].size == 4);
        pragma assert(v3[1].size == 4);
        pragma assert(v3[0][2] == 0);
        pragma assert(v3[1][3] == 0);
    }
}

@test(struct_initializer)
@run(test.test)
contract test {
    type s1 struct {
        int a;
        byte b;
    }
    s1 v1 = new { 1, 'z' };
    s1 v2, v3 = new { 2, '?' }, new { 3, '\n' };

    type s2 struct {
        int64 a;
        string b[2];
    }
    s2 v4 = new { 28, { "seoul", "busan" } };

    type s3 struct {
        int x;
        s1 y;
    }
    s3 v5 = new { 9, { 10, 11 } };

    test() {
        pragma assert(v1.a == 1);
        pragma assert(v1.b == 122);

        pragma assert(v2.a == 2);
        pragma assert(v2.b == 63);

        pragma assert(v3.a == 3);
        pragma assert(v3.b == 10);

        pragma assert(v4.a == 28);
        pragma assert(v4.b[0] == "seoul");
        pragma assert(v4.b[1] == "busan");

        pragma assert(v5.x == 9);
        pragma assert(v5.y.a == 10);
        pragma assert(v5.y.b == 11);

        type s4 struct {
            bool x;
            s2 y;
        }
        s4 v6, v7 = new { true, { 6, { "white", "red" } } },
           new { false, { 7, { "green", "blue" } } };

        pragma assert(v6.x);
        pragma assert(v6.y.a == 6);
        pragma assert(v6.y.b[0] == "white");
        pragma assert(v6.y.b[1] == "red");

        pragma assert(!v7.x);
        pragma assert(v7.y.a == 7);
        pragma assert(v7.y.b[0] == "green");
        pragma assert(v7.y.b[1] == "blue");
    }
}

@test(mismatched_field_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    type s1 struct {
        int a;
        string b;
    }
    s1 v1 = new { "a", "b" };
}

@test(excess_field_count)
@error(ERROR_MISMATCHED_COUNT)
contract test {
    type s1 struct {
        int a;
        string b;
    }
    s1 v1 = new { 1, "b", "c" };
}

@test(shortage_field_count)
@error(ERROR_MISMATCHED_COUNT)
contract test {
    type s1 struct {
        int a;
        string b;
    }
    s1 v1 = new { 1, "b", "c" };
}

@test(struct_allocator)
@run(test.test)
contract test {
    type s1 struct {
        int a;
        byte b;
        string c;
    }
    s1 v1 = new s1;

    test() {
        pragma assert(v1.a == 0);
        pragma assert(v1.b == 0);
        pragma assert(v1.c == "");

        s1 v2;

        pragma assert(v2.a == 0);
        pragma assert(v2.b == 0);
        pragma assert(v2.c == null);
    }
}

@test(struct_array_initializer)
@run(test.test)
contract test {
    type s1 struct {
        int a;
        int b;
        string c;
    }
    s1 v1[2] = new { { 1, 0x80, "a" }, { 2, 0x81, "b" } };
    s1 v2[1], v3[1] = new { { 1, 0x01, "a" } }, new { { 2, 0x02, "b" } };
    s1 v4[2][2] = new {
        { { 1, 0x01, "a" }, { 2, 0x02, "b" } },
        { { 3, 0x03, "c" }, { 4, 0x04, "d" } },
    };

    type s2 struct {
        int x;
        s1 y;
    }
    s2 v5[2] = new { { 1, { 1, 1, "1" } }, { 2, { 2, 2, "2" } } };
    s2 v6[1], v7[1] = new { { 1, { 1, 1, "1" } } }, new { { 2, { 2, 2, "2" } } };

    test() {
        pragma assert(v1[0].a == 1);
        pragma assert(v1[0].b == 128);
        pragma assert(v1[0].c == "a");
        pragma assert(v1[1].a == 2);
        pragma assert(v1[1].b == 129);
        pragma assert(v1[1].c == "b");

        pragma assert(v3[0].a == 2);
        pragma assert(v3[0].b == 2);
        pragma assert(v3[0].c == "b");

        pragma assert(v4[0][0].a == 1);
        pragma assert(v4[0][0].b == 1);
        pragma assert(v4[0][0].c == "a");
        pragma assert(v4[0][1].a == 2);
        pragma assert(v4[0][1].b == 2);
        pragma assert(v4[0][1].c == "b");
        pragma assert(v4[1][0].a == 3);
        pragma assert(v4[1][0].b == 3);
        pragma assert(v4[1][0].c == "c");
        pragma assert(v4[1][1].a == 4);
        pragma assert(v4[1][1].b == 4);
        pragma assert(v4[1][1].c == "d");

        pragma assert(v5[0].x == 1);
        pragma assert(v5[0].y.a == 1);
        pragma assert(v5[0].y.b == 1);
        pragma assert(v5[0].y.c == "1");
        pragma assert(v5[1].x == 2);
        pragma assert(v5[1].y.a == 2);
        pragma assert(v5[1].y.b == 2);
        pragma assert(v5[1].y.c == "2");

        type s3 struct {
            s1 x;
        }
        s3 v8[1] = new { { { 10, 10, "v10" } } };
        s3 v9[2] = new { { { 11, 11, "v11[0]" } }, { { 11, 11, "v11[1]" } } };

        pragma assert(v8[0].x.a == 10);
        pragma assert(v8[0].x.b == 10);
        pragma assert(v8[0].x.c == "v10");

        pragma assert(v9[1].x.a == 11);
        pragma assert(v9[1].x.b == 11);
        pragma assert(v9[1].x.c == "v11[1]");
    }
}

@test(struct_array_allocator)
@run(test.test)
contract test {
    type s1 struct {
        bool a;
        int b;
        string c;
    }
    s1 v1[2];

    test() {
        pragma assert(v1[0].a == false);
        pragma assert(v1[0].b == 0);
        pragma assert(v1[0].c == "");
        pragma assert(v1[1].a == false);
        pragma assert(v1[1].b == 0);
        pragma assert(v1[1].c == null);

        s1 v2[] = new s1[3];

        pragma assert(v2[0].a == false);
        pragma assert(v2[0].b == 0);
        pragma assert(v2[0].c == "");
        pragma assert(v2[1].a == false);
        pragma assert(v2[1].b == 0);
        pragma assert(v2[1].c == null);
        pragma assert(v2[2].a == false);
        pragma assert(v2[2].b == 0);
        pragma assert(v2[2].c == "");
    }
}

@test(map_initializer)
@run(test.test)
contract test {
    map(int, string) m1 = new { { 1, "value1" } };
    map(int, string) m2 = new { { 1, "value1" }, { 2, "value2" } };

    map(bool, map(int, string)) m3 =
        new { { true, { { 3, "3" } } }, { false, { { 4, "4" } } } };

    map(bool, map(int, string)) m4 = new { { true, m1 }, { false, m2 } };

    test() {
        pragma assert(m1[1] == "value1");

        pragma assert(m2[1] == "value1");
        pragma assert(m2[2] == "value2");

        pragma assert(m3[true][3] == "3");
        pragma assert(m3[false][4] == "4");

        pragma assert(m4[true][1] == "value1");
        pragma assert(m4[false][1] == "value1");
        pragma assert(m4[false][2] == "value2");
    }
}

@test(map_allocator)
contract test {
    map(int, string) m1 = new map(int, string);
    map(int64, int256) m2 = new map(int64, int256);
    map(int16, int64) m3 = new map(int16, int64);
    map(int64, int64) m4 = new map(int64, int64);
    map(int, map(int64, int64)) m5 = new map(int, map(int64, int64));
}

@test(map_array_initializer)
@run(test.test)
contract test {
    map(int, string) m1[1] = new {
        { { 1, "value1" } }
    };
    map(int, string) m2[2] = new {
        { { 1, "value1" }, { 2, "value2" }, { 3, "value3" } },
        { { 1, "value1" }, { 2, "value2" }, { 3, "value3" } }
    };

    test() {
        pragma assert(m1.size == 1);
        pragma assert(m1[0][1] == "value1");

        pragma assert(m2.size == 2);
        pragma assert(m2[0][1] == "value1");
        pragma assert(m2[0][2] == "value2");
        pragma assert(m2[0][3] == "value3");
        pragma assert(m2[1][1] == "value1");
        pragma assert(m2[1][2] == "value2");
        pragma assert(m2[1][3] == "value3");
    }
}

@test(map_array_allocator)
contract test {
    map(int, string) m[] = new map(int, string)[2];
}

@test(not_allowed_allocator)
@error(ERROR_NOT_ALLOWED_ALLOC,3)
contract test {
    int i[2] = new int[2];
    type t struct {
        int a;
        string b;
    }
    map(string, t) m[2] = new map(string, t)[2];
    byte b[][4] = new byte[3][4];
}

@test(contract_initializer)
@error(ERROR_MISMATCHED_TYPE)
contract sub {
    int i;
    string s;
}
contract test {
    sub v = new { -1, "failure" };
}

@test(initializer_with_variable)
@run(test.test)
contract test {
    bool b1 = false;
    bool b2[2] = new { true, b1 };
    bool b3[2][3] = new { { true, b1, b1 }, { b1, true, true } };

    int i1 = 128;
    int i2 = 512;
    int i3[3] = new { i1, 256, i2 };

    string s1 = "whale";
    string s2[3] = new { "shark", s1, "dolphin" };

    type r1 struct {
        int a;
        string b;
    }
    r1 v1 = new { -8, s2[0] };

    test() {
        pragma assert(b2[0] == true);
        pragma assert(b2[1] == false);

        pragma assert(b3[0][0] == true);
        pragma assert(b3[0][1] == false);
        pragma assert(b3[0][2] == b1);
        pragma assert(b3[1][0] == false);
        pragma assert(b3[1][1] == true);
        pragma assert(b3[1][2] == true);

        pragma assert(i3[0] == i1);
        pragma assert(i3[1] == 256);
        pragma assert(i3[2] == 512);

        pragma assert(s2[0] == "shark");
        pragma assert(s2[1] == "whale");
        pragma assert(s2[2] == "dolphin");

        pragma assert(v1.a == -8);
        pragma assert(v1.b == "shark");

        r1 v2[2] = new { { v1.a, s1 }, { i1 - 126, v1.b } };

        pragma assert(v2[0].a == -8);
        pragma assert(v2[0].b == "whale");
        pragma assert(v2[1].a == 2);
        pragma assert(v2[1].b == "shark");

        type r2 struct {
            int64 a;
            bool b[3];
            string c;
        }
        r2 v3 = new { 0x9ffffffff, { true, b3[1][0], b1 }, s2[2] };

        pragma assert(v3.a == 42949672959);
        pragma assert(v3.b[0] == true);
        pragma assert(v3.b[1] == false);
        pragma assert(v3.b[2] == false);
        pragma assert(v3.c == "dolphin");
    }
}

@test(not_array_allocator)
@error(ERROR_NOT_ALLOWED_ALLOC)
contract test {
    int i[2] = new int;
}

@test(missing_allocator_size)
@error(ERROR_SYNTAX)
contract test {
    int i[2] = new int[];
}

@test(invalid_allocator_size)
@error(ERROR_INVALID_SIZE_VAL,3)
contract test {
    int i[] = new int[0];
    int j[] = new int["2"];

    int x = 1;
    int k[] = new int[x + 1];
}

@test(mismatched_allocator_size)
@error(ERROR_MISMATCHED_TYPE,2)
contract test {
    int i1[] = new int[1][2];
    int i2[][] = new int[3];
}

@test(mismatched_allocator_type)
@error(ERROR_MISMATCHED_TYPE,3)
contract test {
    int i[] = new int16[2];

    type s struct {
        bool x;
        int256 y;
    }
    s v[] = new s;

    map(int, string) m[] = new map(int64, string)[2];
}
