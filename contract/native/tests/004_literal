@test(numeric_value)
contract test {
    byte b1 = 0;
    byte b2 = +1;
    byte b3 = 0xff;

    int8 i1 = +127;
    int8 i2 = -0x7f;

    uint8 ui1 = 0;
    uint8 ui2 = 0xff;

    int16 i3 = +32767;
    int16 i4 = -0x7fff;

    uint16 ui3 = 0;
    uint16 ui4 = 0xffff;

    int32 i5 = +0x7fffff - 1;
    int32 i6 = -2147483648;

    uint32 ui5 = 0;
    uint32 ui6 = 4294967295;

    int64 i7 = 9223372036854775807;
    int64 i8 = -0x7fffffff;

    uint64 ui7 = 0;
    uint64 ui8 = 18446744073709551615;

    float f1 = 1.0;
    float f2 = +1.1;
    float f3 = -1.2;
    float f4 = 1e1;
    float f5 = -.2e+1;
    float f6 = 3.e-1;
    float f7 = 340282346638528859811704183484516925440.000000;

    double d1 = 1.;
    double d2 = .234;

    int i, j = 1, 0;
}

@test(mismatched_primitive_type)
@error(ERROR_MISMATCHED_TYPE,2)
contract test {
    int i = 1.0;
    float f = 1;
}

@test(numeric_overflow)
@error(ERROR_NUMERIC_OVERFLOW,19)
contract test {
    byte b1 = -1;
    byte b2 = 257;

    int8 i1 = -129;
    int8 i2 = 128;

    uint8 ui1 = -1;
    uint8 ui2 = 257;

    int16 i3 = -32769;
    int16 i4 = 32768;

    uint16 ui3 = -1;
    uint16 ui4 = 65537;

    int32 i5 = -2147483649;
    int32 i6 = 2147483648;

    uint32 ui5 = -1;
    uint32 ui6 = 4294967296;

    int64 i7 = 9223372036854775808;
    int64 i8 = -9223372036854775809;

    uint64 ui7 = -1;

    float f1 = -340282446638528959811704183484516925441.000000;
    float f2 = 340282446638528959811704183484516925441.000000;
}

@test(character_value)
contract test {
    string v1 = "";
    string v2 = "literal";
    string v3 = "literal \"include quotation\"";
    string v4 = "literal /* with */ // comments";
}

@test(unterminated_string)
@error(ERROR_UNTERMINATED_STRING)
contract test {
    string v = "unterminated string\";
}

@test(predefined_constant)
contract test {
    bool v1 = true;
    bool v2 = false;
    string s = null;
    map(int, string) m = null;
}

@test(array_initializer)
contract test {
    bool b1[2] = new { true, false };
    byte b2[2] = new { 0xa, 0xb };

    int8 i1[3] = new { -1, 0, 1, };
    int16 i2[1], i3[2] = new { 1024 }, new { 0x0000, 0xffff } ;

    int i4[1 + 1] = new { 1, 2 };
    int i5[1 * 3 - 1] = new { 3, 4 };

    int i6[2][2] = new { { 1, 2 }, { 3, 4 } };

    int i7[] = new { 4, 5, 6 };
    int i8[] = new { 7 };

    uint32 u1[3] = new { 0, 1, 2, };
    uint64 u2[1], u3[2] = new { 1 }, new { 2, 3 } ;

    string s[3] = new { "a", "b", "c" };
}

@test(empty_initializer)
@error(ERROR_SYNTAX)
contract test {
    int i[1] = new { };
}

@test(non_array_initializer)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i = new { 1, 2 };
}

@test(invalid_array_brace)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i[] = new { { 1, 2, 3 } };
}

@test(mismatched_element_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i[2][2] = new { { 1, 1 }, { 2, "2" } };
}

@test(excess_element_count)
@error(ERROR_MISMATCHED_COUNT)
contract test {
    int i[1] = new { 1, 2 };
}

@test(shortage_element_count)
@error(ERROR_MISMATCHED_COUNT)
contract test {
    int i[2] = new { 1 };
}

@test(array_allocator)
contract test {
    bool b[1] = new bool[1];
    int64 i[2] = new int64[2];
    double d[3] = new double[3];
    string s[4] = new string[4];

    int v1[] = new int[2];
    int v2[][] = new int[2][2];
    int v3[][4] = new int[2][4];
}

@test(struct_initializer)
contract test {
    type s1 struct {
        int a;
        byte b;
        string c;
    }
    s1 v1 = new { 1, 0x01, "a" };
    s1 v2, v3 = new { 1, 0x01, "a" }, new { 2, 0x02, "b" };

    type s2 struct {
        uint16 a;
        double b[2];
    }
    s2 v4 = new { 128, { 5.34, 314e-2 } };

    type s3 struct {
        int x;
        s1 y;
    }
    s3 v5 = new { 1, { 1, 1, "1" } };
    s3 v6, v7 = new { 1, { 1, 0x01, "a" } }, new { 2, { 2, 0x02, "b" } };
}

@test(mismatched_field_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    type s1 struct {
        int a;
        string b;
    }
    s1 v1 = new { "a", "b" };
}

@test(excess_field_count)
@error(ERROR_MISMATCHED_COUNT)
contract test {
    type s1 struct {
        int a;
        string b;
    }
    s1 v1 = new { 1, "b", "c" };
}

@test(shortage_field_count)
@error(ERROR_MISMATCHED_COUNT)
contract test {
    type s1 struct {
        int a;
        string b;
    }
    s1 v1 = new { 1, "b", "c" };
}

@test(struct_allocator)
contract test {
    type s1 struct {
        int a;
        byte b;
        string c;
    }
    s1 v1 = new s1;
    s1 v2 = new s1;
}

@test(struct_array_initializer)
contract test {
    type s1 struct {
        int a;
        int b;
        string c;
    }
    s1 v2[2] = new { { 1, 0x01, "a" }, { 2, 0x02, "b" } };
    s1 v3[1], v4[1] = new { { 1, 0x01, "a" } }, new { { 2, 0x02, "b" } };
    s1 v5[2][2] = new {
        { { 1, 0x01, "a" }, { 2, 0x02, "b" } },
        { { 3, 0x03, "c" }, { 4, 0x04, "d" } },
    };

    type s2 struct {
        int x;
        s1 y;
    }
    s2 v6[2] = new { { 1, { 1, 1, "1" } }, { 2, { 2, 2, "2" } } };
    s2 v7[1], v8[1] = new { { 1, { 1, 1, "1" } } }, new { { 2, { 2, 2, "2" } } };

    type s3 struct {
        s1 x;
    }
    s3 v10[1] = new { { { 10, 10, "v10" } } };
    s3 v11[2] = new { { { 11, 11, "v11[0]" } }, { { 11, 11, "v11[1]" } } };
}

@test(struct_array_allocator)
contract test {
    type s1 struct {
        bool a;
        int b;
        string c;
    }
    s1 v1[2] = new s1[2];
    s1 v2[3] = new s1[3];
}

@test(map_initializer)
contract test {
    map(int, string) m1 = new { { 1, "value1" } };
    map(int, string) m2 = new { { 1, "value1" }, { 2, "value2" } };

    map(bool, map(int, string)) m3 = 
        new { { true, { { 3, "3" } } }, { false, { { 4, "4" } } } };

    map(bool, map(int, string)) m4 = new { { true, m1 }, { false, m2 } };
}

@test(map_allocator)
contract test {
    map(int, string) m1 = new map(int, string);
}

@test(map_array_initializer)
contract test {
    map(int, string) m1[1] = new {
        { { 1, "value1" } }
    };
    map(int, string) m2[2] = new {
        { { 1, "value1" }, { 2, "value2" }, { 3, "value3" } },
        { { 1, "value1" }, { 2, "value2" }, { 3, "value3" } }
    };
}

@test(map_array_allocator)
contract test {
    map(int, string) m1[2] = new map(int, string)[2];
    map(int, string) m2[] = new map(int, string)[2];
}

@test(contract_initializer)
@error(ERROR_MISMATCHED_TYPE)
contract sub {
    int i;
    string s;
}
contract test {
    sub v = new { -1, "failure" };
}

@test(initializer_with_variable)
contract test {
    bool b1 = false;
    bool b2[2] = new { true, b1 };
    bool b3[2][3] = new { { true, b1, b1 }, { b1, true, true } };

    int i1 = 128;
    int i2 = 512;
    int i3[3] = new { i1, 256, i2 };

    string s1 = "No.2";
    string s2[3] = new { "No.1", s1, "No.3" };

    type s struct {
        int a;
        string b;
    }
    s v1 = new { -8, s1 };
    s v2[2] = new { { v1.a, s1 }, { i1 - 126, v1.b } };
}

@test(not_array_allocator)
@error(ERROR_INVALID_INITIALIZER)
contract test {
    int i[2] = new int;
}

@test(missing_allocator_size)
@error(ERROR_SYNTAX)
contract test {
    int i[2] = new int[];
}

@test(invalid_allocator_size)
@error(ERROR_INVALID_SIZE_VAL,3)
contract test {
    int i[2] = new int[0];
    int j[2] = new int["2"];

    int x = 1;
    int k[2] = new int[x + 1];
}

@test(mismatched_allocator_size)
@error(ERROR_MISMATCHED_COUNT,5)
contract test {
    int i1[2] = new int[1];
    int i2[2] = new int[3];
    int i3[2][2] = new int[2][3];

    type s1 struct {
        int a;
        int b;
    }
    s1 v[2] = new s1[1];

    map(int, string) m[2] = new map(int, string)[3];
}

@test(mismatched_allocator_type)
@error(ERROR_MISMATCHED_TYPE,3)
contract test {
    int i[2] = new int16[2];

    type s1 struct {
        bool a;
        double b;
    }
    s1 s[1] = new s1;

    map(int, string) m[2] = new map(int, string);
}
