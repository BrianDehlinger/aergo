@test(empty_function)
contract test {
    func f1() { }
    func f2() {
        ;
    }
}

@test(function_modifier)
contract test {
    public func f1() { }
    public payable func f2() { }
    payable func f3() { }
}

@test(invalid_payable_modifier)
@error(ERROR_SYNTAX)
contract test {
    payable public func f1() { }
}

@test(duplicated_function)
@error(ERROR_DUPLICATED_ID)
contract test {
    func f1() { }
    func f1() { }
}

@test(duplicated_name_with_variable)
@error(ERROR_DUPLICATED_ID)
contract test {
    int f;
    func f() { }
}

@test(parameter_declaration)
contract test {
    func f1(int p1) { }
    func f2(int p1, string p2) { }
    func f3(int p1, map(int, string) p2) { }
    func f4(int p1[]) { }
    func f5(const int p1) { }
    func f6(string p1, const string p2) { }
}

@test(access_parameters)
@run(test.test)
contract test {
    type s struct {
        int a;
        string b;
    }
    s v;
    map(int, string) m;
    func f1(int x, string y) { v.a = x; v.b = y; }
    func f2(int x, string y) { m[x] = y; }
    func f3(s p) int128 {
        int i;
        int128 j;
        for (i = 0; i < p.a; i++) { j++; }
        if (p.b == "b") { j++; }
        return j;
    }
    test() {
        f1(1, "1");
        pragma assert(v.a == 1);
        pragma assert(v.b == "1");

        f2(2, "2");

        int128 v;
        v = f3(new { 5, "b" });
        pragma assert(v == 6);
        v = f3(new { 5, "b1" });
        pragma assert(v == 5);
    }
}

@test(overwrite_parameter)
@run(test.test)
contract test {
    func f(int x, string y) {
        x++;
        y += "invalid";
    }
    test() {
        int p1 = 1;
        string p2 = "time";

        f(p1, p2);
        pragma assert(p1 == 1);
        pragma assert(p2 == "time");
    }
}

@test(access_constant_parameter)
@error(ERROR_INVALID_LVALUE)
contract test {
    func f1(const int x) {
        x = 1;
    }
}

@test(array_as_parameter)
@run(test.test)
contract test {
    func f1(int p1[]) {
        p1[0] = 1;
    }
    func f2(int p1[2]) {
        p1[0] = 5;
        p1[1] = 6;
    }

    test() {
        int x[] = new { 3, 4 };

        f1(x);
        pragma assert(x[0] == 1);
        pragma assert(x[1] == 4);

        f2(x);
        pragma assert(x[0] == 5);
        pragma assert(x[1] == 6);
    }
}

@test(contract_as_parameter)
@run(test.test)
contract test {
    int16 a;
    string b;

    func f1(test p) {
        p.a = f2();
        p.b = p.f3();
    }
    func f2() int16 {
        return -10;
    }
    func f3() string {
        return "train";
    }

    test() {
        f1(this);
        pragma assert(a == -10);
        pragma assert(b == "train");
    }
}

@test(return_declaration)
contract test {
    func f1() { return; }
    func f2() int { return 1; }
    //func f3() int, string { return 1 + 1, "value"; }
    func f4() map(int, string) { return null; }
}

@test(return_primitive)
@run(test.test)
contract test {
    func f1(int x) int { return x + 1; }
    func f2(int x, int y) int { return x * y; }
    func f3(int x) string { return (string)x; }

    int i = f1(5);

    test() {
        pragma assert(i == 6);

        pragma assert(f2(3, 3) == 9);
        pragma assert(f2(6, 8) == 48);
        pragma assert(f2(-9, 4) == -36);
        pragma assert(f2(-7, -10) == 70);

        pragma assert(f3(218) == "218");
        pragma assert(f3(0) == "0");
        pragma assert(f3(-27) == "-27");
        pragma assert(f3(0xa8) == "168");
    }
}

@test(return_array)
@run(test.test)
contract test {
    func f1() int[2] { return new int[2]; }
    func f2() int16[3] { return new { -32768, 0, 32767 }; }
    //func f3() float[] { return new float[3]; }
    //func f4() double[] { return new { -29.2134 }; }
    func f5() string[][] {
        return new { { "January", null }, { "March", "April" }, { null, "June" } };
    }

    test() {
        int i[] = f1();
        pragma assert(i.size == 2);

        i[0] = -87;
        pragma assert(i[0] == -87);
        pragma assert(i[1] == 0);

        int16 j[] = f2();
        pragma assert(j.size == 3);

        j[1] = 1027;
        pragma assert(j[0] == -32768);
        pragma assert(j[1] == 1027);
        pragma assert(j[2] == 32767);

        /*
        float f[] = f3();
        f[2] = 12.50;

        double d[] = f4();
        d[0] += 29.2133;
        */

        string s[][] = f5();
        pragma assert(s.size == 3);
        pragma assert(s[0].size == 2);
        pragma assert(s[1].size == 2);
        pragma assert(s[2].size == 2);

        s[2][0] = "May";
        pragma assert(s[0][0] == "January");
        pragma assert(s[0][1] == null);
        pragma assert(s[1][0] == "March");
        pragma assert(s[1][1] == "April");
        pragma assert(s[2][0] == "May");
        pragma assert(s[2][1] == "June");
    }
}

@test(return_struct)
@run(test.test)
contract test {
    type s struct {
        int a;
        string b;
    }

    func f1(int x, string y) s { s v = new { x, y }; return v; }
    func f2(int x, string y) s { return new { x, y }; }

    test() {
        s v = f1(1, "google");
        pragma assert(v.a == 1);
        pragma assert(v.b == "google");

        pragma assert(f1(2, "apple").a == 2);
        pragma assert(f1(2, "apple").b == "apple");

        pragma assert(f2(3, "blocko").a == 3);
        pragma assert(f2(3, "blocko").b == "blocko");
    }
}

@test(return_map)
contract test {
    func f() map(int, string) { return new map(int, string); }

    test() {
        map(int, string) m = f();
        m[1] = f()[1];
    }
}

@test(return_function)
@run(test.test)
contract test {
    func f1(int64 x) int128 { return (int128)x * 2; }
    func f2(int32 x) int64 { return (int64)f1((int64)x); }

    test() {
        int64 v = f2(128);
        pragma assert(v == 256);

        pragma assert(f2(-99) == -198);
        pragma assert(f2(2147483647) == 4294967294);
    }
}

@test(return_contract)
contract ref {
    public int a;
    public string b;
    public func f() bool { return true; }
}

contract test {
    func f() ref { return new ref(); }

    test() {
        ref v = f();
        int a1 = v.a;
        string b1 = v.b;
        bool c1 = v.f();

        int a2 = f().a;
        string b2 = f().b;
        bool c2 = f().f();
    }
}

@test(return_value_overflow)
@error(ERROR_NUMERIC_OVERFLOW)
contract test {
    func f1() int8 { return 1024; }
}

@test(missing_return_statement)
@error(ERROR_MISSING_RETURN,2)
contract test {
    //func f1() double { }
    func f2() string {
        //double v = f1();
    }
    func f3() int {
        int x;
    }
}

@test(function_as_lvalue)
@error(ERROR_INVALID_LVALUE,2)
contract test {
    type s struct {
        int a;
    }
    func f1() int { return 1; }
    func f2() s { return new { 1 }; }

    test() {
        f1() = 2;
        f2().a = 3;
    }
}

@test(function_declaration_order)
contract test {
    test() {
        int v = f1();
    }
    func f1() int { return 1; }
}

@test(goto_across_function)
@error(ERROR_UNDEFINED_LABEL)
contract test {
    func f1() { here: ; }
    func f2() { goto here; }
}

@test(access_private_function)
@error(ERROR_UNDEFINED_ID)
contract test1 {
    func f() { }
}
contract test2 {
    func f() { new test1().f(); }
}

@test(call_across_contract)
contract neighbor {
    public int v;
    neighbor(int p) {
        v = p;
    }
    public func f() int {
        return v;
    }
}

contract test {
    int v;
    func f() int {
        neighbor n = new neighbor(1);
        v = n.v;
        return n.f();
    }
}

@test(builtin_functions)
@run(test.test)
contract test {
    test() {
        pragma assert((int8)abs32((int32)1) == 1);
        pragma assert((int16)abs32((int32)0) == 0);
        pragma assert(abs32(-1) == 1);
        pragma assert(abs64(-2) == 2);
        pragma assert(abs128(-3) == 3);

        pragma assert(lower("LOWER") == "lower");
        pragma assert(upper("upper") == "UPPER");
    }
}
