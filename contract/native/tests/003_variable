@test(primitive_type)
contract test {
    int8 v1;
    int16 v2;
    int32 v3;
    int64 v4;
    int128 v5;
    int v6;

    //float v7;
    //double v8;
    bool v9;
    byte v10;
    string v11;
    int v12, v13;
}

@test(invalid_declaration)
@error(ERROR_SYNTAX)
contract test {
    int v1, string v2;
}

@test(invalid_identifier)
@error(ERROR_SYNTAX)
contract test {
    int 1v;
}

@test(duplicated_identifier)
@error(ERROR_DUPLICATED_ID)
contract test {
    int v;
    string v;
}

@test(too_long_identifier)
@error(ERROR_TOO_LONG_ID)
contract test {
    int v11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111;
}

@test(constant_qualifier)
contract test {
    const int v1 = 0;
    const string v2 = "";
}

@test(invalid_qualifier_position)
@error(ERROR_SYNTAX)
contract test {
    int const v = 0;
}

@test(constant_tuple_variables)
contract test {
    const byte x, y = 0, 255;
    //const double x, y = 0.1, 0.2;
}

@test(missing_constant_value)
@error(ERROR_MISSING_CONST_VAL,3)
contract test {
    const int v;
    const string s1, s2;
}

@test(type_modifier)
contract test {
    public int v1;
    public bool v2;
}

@test(invalid_modifier_position)
@error(ERROR_SYNTAX)
contract test {
    int public v1;
}

@test(out_of_scope_variable)
@error(ERROR_UNDEFINED_ID)
contract test {
    int i = j;
    int j;
}

@test(self_reference)
@error(ERROR_UNDEFINED_ID)
contract test {
    int i = i;
}

@test(case_sensitive_variable)
contract test {
    int i;
    int I;
}

@test(primitive_array)
contract test {
    int i1[10];
    int i2, i3[10];
    int i4[10], i5;
    int i6[10], i7[10];
    int i8[10][10];

    string s1[1 + 1];
    string s2[1 + 1 * 3];

    byte b1[2][2];
    byte b2, b3[2][2];
}

@test(non_integer_size_type)
@error(ERROR_INVALID_SIZE_VAL)
contract test {
    int i["1"];
}

@test(zero_size_value)
@error(ERROR_INVALID_SIZE_VAL)
contract test {
    int i[0];
}

@test(constant_size_variable)
contract test {
    const int i = 1;
    int j[i];
}

@test(non_constant_size_variable)
@error(ERROR_INVALID_SIZE_VAL)
contract test {
    int i;
    int j[i];
}

@test(missing_array_size)
@error(ERROR_MISSING_ARR_SIZE)
contract test {
    int i[];
}

@test(invalid_brace_position)
@error(ERROR_SYNTAX)
contract test {
    int[10] v;
}

@test(missing_declarator)
@error(ERROR_SYNTAX)
contract test {
    int;
}

@test(missing_semicolon)
@error(ERROR_SYNTAX)
contract test {
    int v
}

@test(struct_type)
contract test {
    type s1 struct {
        int a;
        byte b;
        bool c[10];
    }
    s1 v1;

    type s2 struct {
        s1 a;
        string b;
    }
    s2 v2;
}

@test(array_field_of_struct)
@error(ERROR_MISSING_ARR_SIZE)
contract test {
    type s struct {
        string a[];
    }
    s v;
}

@test(struct_array)
contract test {
    type s struct {
        int a, b;
        string c;
    }
    s x[10];
    s y[10][1];
}

@test(empty_struct)
@error(ERROR_SYNTAX)
contract test {
    type s struct {
    }
}

@test(struct_of_struct)
@error(ERROR_SYNTAX)
contract test {
    type outer struct {
        type inner struct {
            int a;
        }
    }
}

@test(enum_type)
contract test {
    enum e1 {
        a,
        b,
    }
    enum e2 {
        a = 0,
        b = 1 + 1,
        c = 4,
        d = 2 * 2 + 1
    }
}

@test(duplicated_enumerator)
@error(ERROR_DUPLICATED_ENUM)
contract test {
    enum e1 {
        a,
        b,
        c = 1,
        d
    }
}

@test(non_integer_enumerator)
@error(ERROR_INVALID_ENUM_VAL)
contract test {
    enum e1 {
        a,
        b,
        c = "3",
        d
    }
}

@test(map_type)
contract test {
    map(int, int) m1;
    map(int8, int8) m2;
    map(int16, int16) m3;
    map(int32, int32) m4;
    map(int64, int64) m5;
    //map(float, float) m6;
    //map(double, double) m7;
    map(bool, bool) m8;
    map(byte, byte) m9;
    map(string, string) m10;
    map(int, int) m11, m12;

    type x struct {
        int a;
    }
    map(int, x) m13;
    map(int, map(string, string)) m14;
    map(x, x) m15;
    map(x, map(string, string)) m16;
}

@test(map_array)
contract test {
    map(int, int) m1[1];
    map(int, int) m2[1], m3[2];
    map(int, int) m4[2][2];
}

@test(invalid_key_type)
@error(ERROR_NOT_COMPARABLE_TYPE)
contract test {
    map(map(int, int), string) m1;
}

@test(reserved_words)
@error(ERROR_SYNTAX,22)
contract test {
    int break;
    int case;
    int const;
    int continue;
    int default;
    int else;
    int enum;
    int false;
    int for;
    int func;
    int goto;
    int if;
    int in;
    int new;
    int null;
    int payable;
    int public;
    int return;
    int struct;
    int switch;
    int true;
    int type;

    int contract;
    int interface;
    int import;
}
