@test(primitive_type)
contract test {
    int v1;
    int8 v2;
    int16 v3;
    int32 v4;
    int64 v5;
    uint v6;
    uint8 v7;
    uint16 v8;
    uint32 v9;
    uint64 v10;
    float v11;
    double v12;
    bool v13;
    byte v14;
    string v15;
    int v16, v17;
}

@test(incompatible_declaration)
@error(ERROR_SYNTAX)
contract test {
    int v1, string v2;
}

@test(constant_qualifier)
contract test {
    const int v;
}

@test(invalid_qualifier_position)
@error(ERROR_SYNTAX)
contract test {
    int const v;
}

@test(type_modifier)
contract test {
    local int v1;
}

@test(invalid_modifier_position)
@error(ERROR_SYNTAX)
contract test {
    int local v1;
}

@test(primitive_array)
contract test {
    int v1[10];
    int v2, v3[10];
    int v4[10], v5;
    int v6[10], v7[10];
}

@test(invalid_brace_position)
@error(ERROR_SYNTAX)
contract test {
    int[10] v;
}

@test(missing_declarator)
@error(ERROR_SYNTAX)
contract test {
    int;
}

@test(missing_semicolon)
@error(ERROR_SYNTAX)
contract test {
    int v
}

@test(struct_type)
contract test {
    struct s1 {
        int a;
        byte b;
        bool c[10];
    }
    s1 v1;

    struct s2 {
        s1 a;
    }
}

@test(struct_array)
contract test {
    struct s {
        int a, b;
        string c;
    }
    s y[10];
}

@test(empty_struct)
@error(ERROR_SYNTAX)
contract test {
    struct s {
    }
    s x[10];
}

@test(struct_of_struct)
@error(ERROR_SYNTAX)
contract test {
    struct outer {
        struct inner {
            int a;
        }
    }
    s x;
}

@test(map_type)
contract test {
    map(int, string) v1;
    struct x {
        int a;
    }
    map(x, string) v2;
    map(byte, x) v3;
    map(int, map(int, string)) v4;
}
