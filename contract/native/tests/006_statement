@test(assignment)
@run(test.test)
contract test {
    int i1;
    string s1;
    test() {
        i1 = 1;
        pragma assert(i1 == 1);
        i1 += 1;
        pragma assert(i1 == 2);
        i1 -= 1;
        pragma assert(i1 == 1);
        i1 *= 1 + 1;
        pragma assert(i1 == 2);
        i1 /= 2;
        pragma assert(i1 == 1);
        i1 %= 10;
        pragma assert(i1 == 1);

        int i2;
        i2 = i1;
        pragma assert(i2 == 1);
        i2 |= 0xff;
        pragma assert(i2 == 0xff);
        i2 &= 0x01;
        pragma assert(i2 == 1);
        i2 ^= 0x01;
        pragma assert(i2 == 0);

        s1 = "first";
        pragma assert(s1 == "first");
        s1 += ", second";
        pragma assert(s1 == "first, second");

        string s2;
        s2 = s1;
        pragma assert(s2 == "first, second");
    }
}

@test(invalid_lvalue)
@error(ERROR_INVALID_LVALUE,5)
contract test {
    const int i = 0;
    int j, k;
    type t struct { int x; }
    test() {
        1 = 1;
        i = 1;

        j + 1 = 1;
        i == 0 ? j : k = 1;

        const t v = new { 1 };
        v.x = 2;
    }
}

@test(mismatched_tuple_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i;
    string s;
    test() {
        i, s = 1, 2;
    }
}

@test(array_assignment)
@run(test.test)
contract test {
    int i[2][3] = new { { 1, 2, 3 }, { 4, 5, 6 } };
    test() {
        i[0][0] = 17;
        pragma assert(i[0][0] == 17);
        i[1][0] = 10;
        pragma assert(i[1][0] == 10);

        int j[5] = new { 1, 2, 3, 4, 5 };
        j[0] = 0;
        pragma assert(j[0] == 0);
        j[0] += 1;
        pragma assert(j[0] == 1, (string)j[0]);
        j[0]++;
        pragma assert(j[0] == 2);

        int idx = 1;
        j[idx] = j[0];
        pragma assert(j[1] == 2, (string)j[1]);
        j[idx]--;
        pragma assert(j[1] == 1);

        j[idx + 1] = j[0] + j[idx];
        pragma assert(j[2] == 3);
        j[idx + 2] = 7;
        pragma assert(j[3] == 7);

        int64 k[3][2] = new { { 1, 2 }, { 3, 4 }, { 5, 6 } };
        k[0][1] = 7;
        pragma assert(k[0][1] == 7);
        k[1][0] = 8;
        pragma assert(k[1][0] == 8);
        k[2][1] = 9;
        pragma assert(k[2][1] == 9);
        k[idx][idx - 1] = 10;
        pragma assert(k[1][0] == 10);
        k[2][idx] = 11;
        pragma assert(k[2][1] == 11);

        int l[][] = i;
        int m[] = i[1];
        pragma assert(m.size == 3);
        pragma assert(m[0] == 10);
        pragma assert(m[1] == 5);
        pragma assert(m[2] == 6);
    }
}

@test(invalid_array_assignment)
@error(ERROR_INVALID_LVALUE)
contract test {
    int i[2][2];
    int j[2];
    test() {
        i[0] = j;
    }
}

@test(mismatched_array_dimension)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i[2][2];
    test() {
        int j[] = i;
    }
}

@test(index_out_of_range)
@error(ERROR_INVALID_ARR_IDX,2)
contract test {
    test() {
        int i[2];
        i[1 + 1] = 1;
        i[1 - 2] = 1;
    }
}

@test(invalid_array_subscription)
@error(ERROR_INVALID_SUBSCRIPT)
contract test {
    test() {
        int i;
        i[0] = 1;
    }
}

@test(struct_assignment)
@run(test.test)
contract test {
    type s1 struct { int a, b; }
    test() {
        s1 v1;
        s1 v2 = new { 11, -11 };
        v1 = v2;
        pragma assert(v1.a == 11);
        pragma assert(v1.b == -11);
        v2.b = -13;
        pragma assert(v1.a == 11);
        pragma assert(v1.b == -13);
        v2 = v1;
        pragma assert(v2.a == 11);
        pragma assert(v2.b == -13);
    }
}

@test(struct_array_assignment)
@run(test.test)
contract test {
    type s1 struct { int a, b; }
    test() {
        s1 v1[2][2] = new {
            { { 1, 2 }, { 3, 4 } },
            { { 5, 6 }, { 7, 8 } },
        };
        s1 v2[3];
        s1 v3 = new { 9, 10 };

        v1[0][1] = v3;
        pragma assert(v1[0][1].a == 9);
        pragma assert(v1[0][1].b == 10);
        v2[1] = v3;
        pragma assert(v2[1].a == 9);
        pragma assert(v2[1].b == 10);
        v3 = v1[1][0];
        pragma assert(v3.a == 5);
        pragma assert(v3.b == 6);
        v3 = v2[2];
        pragma assert(v3.a == 0);
        pragma assert(v3.b == 0);
        s1 v4[][] = v1;
        pragma assert(v4[0][0].a == 1);
        pragma assert(v4[0][0].b == 2);
        pragma assert(v4[0][1].a == 9);
        pragma assert(v4[0][1].b == 10);
        pragma assert(v4[1][0].a == 5);
        pragma assert(v4[1][0].b == 6);
        pragma assert(v4[1][1].a == 7);
        pragma assert(v4[1][1].b == 8);
        s1 v5[] = v1[0];
        pragma assert(v5[0].a == 1);
        pragma assert(v5[0].b == 2);
        pragma assert(v5[1].a == 9);
        pragma assert(v5[1].b == 10);
        s1 v6[] = v2;
        pragma assert(v6[0].a == 0);
        pragma assert(v6[0].b == 0);
        pragma assert(v6[1].a == 9);
        pragma assert(v6[1].b == 10);
        pragma assert(v6[2].a == 0);
        pragma assert(v6[2].b == 0);
        v6[0].a = 0xf0;
        /*
        v6[0].b = 0xf1;
        /*
        pragma assert(v2[0].a == 0xf0);
        pragma assert(v2[0].b == 0xf1);
        */
    }
}

@test(map_assignment)
contract test {
    test() {
        map(int, string) m1;
        m1[1] = "1";
        m1[2] = "2";

        map(int, string) m2 = m1;

        type s struct {
            int a;
            string b;
        }
        s v1 = new { 1, "1" };
        s v2 = new { 2, "2" };

        map(string, s) m3;
        m3["1"] = v1;
        m3["2"] = v2;

        map(s, int) m4;
        m4[v1] = 1;
        m4[v2] = 2;
    }
}

@test(map_array_assignment)
contract test {
    test() {
        map(int, string) m1[2];
        map(int, string) m2;

        m1[0] = m2;
        m1[1] = m2;
        m2 = m1[0];

        map(int, string) m3[] = m1;
        m3[0] = m2;
    }
}

@test(mismatched_map_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    test() {
        type s1 struct { int a; }
        type s2 struct { string a; }
        s2 v = new { "2" };

        map(int, s1) m;
        m[1] = v;
    }
}

@test(tuple_assignment)
@run(test.test)
contract test {
    string s1, s2;

    test() {
        int i1, i2 = 1, 2;
        pragma assert(i1 == 1);
        pragma assert(i2 == 2);
        (i1, i2) = 1 * 3, 4;
        pragma assert(i1 == 3);
        pragma assert(i2 == 4);

        s1, s2 = ("a", "b");
        pragma assert(s1 == "a");
        pragma assert(s2 == "b");
        s1, s2 = "c", "d";
        pragma assert(s1 == "c");
        pragma assert(s2 == "d");

        i1, s1 = 5, "e";
        pragma assert(i1 == 5);
        pragma assert(s1 == "e");
    }
}

@test(mismatched_tuple_count)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    test() {
        int i, j;
        i, j = 1;
    }
}

@test(array_access)
@run(test.test)
contract test {
    string s[][] = new {
        { "songtan", "osan", "suwon" },
        { "busan", "daegu", "ulsan" }
    };
    test() {
        int i[5] = new { 1, 2, 3, 4, 5 };

        int j = i.size;
        pragma assert(j == 5);

        j = s.size;
        pragma assert(j == 2);

        j = s[1].size;
        pragma assert(j == 3);

        j = s[1].size;
        pragma assert(j == 3);
    }
}

@test(invalid_array_access)
@error(ERROR_INVALID_LVALUE,2)
contract test {
    test() {
        int i[5] = new { 1, 2, 3, 4, 5 };
        i.size = 5;
        i.size++;
    }
}

@test(struct_access)
@run(test.test)
contract test {
    type s struct {
        int a;
        string b[2];
        map(int, bool) c;
        //double d[2];
    }
    test() {
        s v = new { 1, { "apple", "orange" }, { { 1, true } } };
        pragma assert(v.a == 1);
        pragma assert(v.b[0] == "apple");
        pragma assert(v.b[1] == "orange");

        v.a++;
        pragma assert(v.a == 2);

        v.a |= 0xabcd;
        pragma assert(v.a == 43983);

        v.b[0] += " is delicious";
        pragma assert(v.b[0] == "apple is delicious");

        v.a, v.b[1] = 2, "banana";
        pragma assert(v.a == 2);
        pragma assert(v.b[1] == "banana");

        v.c[1] = false;
    }
}

@test(enum_access)
@run(test.test)
contract test {
    enum e { a, b, c, d }
    test() {
        byte b = e.a;
        pragma assert(b == 0);
        int8 i1 = e.b;
        pragma assert(i1 == 1);
        int32 i2 = e.c;
        pragma assert(i2 == 2);
        int64 i3 = e.d;
        pragma assert(i3 == 3);
    }
}

@test(incompatible_enum_access)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    enum e { a }
    test() {
        bool b = e.a;
        /*
        float f = e.a;
        double d = e.a;
        */
    }
}

@test(using_enum_as_lvalue)
@error(ERROR_INVALID_LVALUE)
contract test {
    enum e { a }
    test() {
        e.a = 3;
    }
}

@test(primitive_variable_access)
@error(ERROR_INACCESSIBLE_TYPE,3)
contract test {
    int i = 0;
    string s = "keyboard";
    test() {
        i.size;
        s.length;
        "mouse".length;
    }
}

@test(expression_statement)
@run(test.test)
contract test {
    test() {
        int x;
        x;
        pragma assert(x == 0);
        x++;
        pragma assert(x == 1);
        x == 1 ? 1 : 0;
    }
}

@test(if_else)
@run(test.test)
contract test {
    string s;

    func f1(bool cond) {
        if (cond) {
            s = "this is if";
        }
        else {
            s = "this is else";
        }
    }
    func f2(int v) string {
        if (v == 1) {
            return "gold";
        }
        else if (v == 2) {
            return "silver";
        }
        else if (v == 3) {
            return "bronze";
        }
        else {
            return "out of rank";
        }
    }

    test() {
        if (0 == 0) {
            pragma assert(true);
        }
        else {
            pragma assert(false);
        }

        f1(true);
        pragma assert(s == "this is if");

        f1(false);
        pragma assert(s == "this is else");

        pragma assert(f2(1) == "gold");
        pragma assert(f2(2) == "silver");
        pragma assert(f2(3) == "bronze");
        pragma assert(f2(4) == "out of rank");
    }
}

@test(missing_if_parenthesis)
@error(ERROR_SYNTAX)
contract test {
    test() { if 1 == 1 { } }
}

@test(missing_if_brace)
@error(ERROR_SYNTAX)
contract test {
    test() { if (1 == 1); }
}

@test(non_boolean_if_condition)
@error(ERROR_INVALID_COND_TYPE)
contract test {
    test() { if (1) { } }
}

@test(switch_case)
@run(test.test)
contract test {
    string s;

    func f1(int i) {
        switch (i) {
        case 1: s = "case 1"; break;
        case 2:
            {
                s = "case 2";
            }
            break;
        case 3: case 4: s = "case unknown"; break;
        default: break;
        }
    }
    func f2(int64 i) {
        switch (i) {
        case 1: s = "case 1";
        case 2: case 3: s = "case 2";
        }
    }

    test() {
        f1(1);
        pragma assert(s == "case 1");
        f1(2);
        pragma assert(s == "case 2");
        f1(3);
        pragma assert(s == "case unknown");
        f1(4);
        pragma assert(s == "case unknown");
        s = "default";
        f1(5);
        pragma assert(s == "default");

        s = null;
        f2(1);
        pragma assert(s == "case 2");
        f2(2);
        pragma assert(s == "case 2");

        s = null;
        f2(4);
        pragma assert(s == null);
    }
}

@test(mismatched_case_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i;

    test() {
        switch (i) {
        case 1: break;
        case "2": break;
        }
    }
}

@test(duplicated_case_value)
@error(ERROR_DUPLICATED_CASE)
contract test {
    int i;

    test() {
        switch (i) {
        case 1: break;
        case 1: i++;
        }
    }
}

@test(duplicated_default)
@error(ERROR_DUPLICATED_LABEL)
contract test {
    int i;

    test() {
        switch (i) {
        case 1: break;
        default: i++; break;
        default: i--; break;
        }
    }
}

@test(non_case_statement)
@error(ERROR_INVALID_CASE,2)
contract test {
    int i;

    test() {
        switch (i) {
fake_label:
        i = 0;
        case 1: break;
        i = 1;
        }
    }
}

@test(without_switch_variable)
@run(test.test)
contract test {
    int i;
    string s;

    test() {
        switch {
        case i == 1: { } break;
        case s == "second": break;
        }
    }
}

@test(duplicated_case_expression)
@error(ERROR_DUPLICATED_CASE)
contract test {
    int i;
    string s;

    test() {
        switch {
        case i == 1: { } break;
        case i == 1: break;
        }
    }
}

@test(non_boolean_case_condition)
@error(ERROR_INVALID_COND_TYPE)
contract test {
    test() {
        switch {
        case 1 == 1: break;
        case 2: break;
        }
    }
}

@test(for_loop)
@run(test.test)
contract test {
    int v;

    test() {
        int i;
        for (i = 0; i < 10; i++) { break; }
        for (i = 0; i < 10; ) { break; }
        for (i = 0; ; ) { break; }
        for ( ; i < 10; ) { break; }
        for ( ; i < 10; i++) { break; }
        for ( ; ; i++) { break; }
        for ( ; ; ) { break; }
        for (true) { break; }
        for { break; }

        for (int j = 1; j >= 0; j--) { }
        for (int j = i; j >= 0; ) { break; }
        for (int j = i; ; ) { break; }

        int j;
        for (i, j = 0, 5; i < 10 && j >= 0; i++, j--) { }

        for (i = 0; i < 10; i++) { v += i; }
        pragma assert(v == 45);

        v = 1;
        for (i, j = 0, 5; i < 10 && j >= 0; i++, j--) { v *= 2; }
        pragma assert(v == 64);
    }
}

@test(iterator_scope)
@run(test.test)
contract test {
    test() {
        int i = 1;
        for (int i = 0; i <= 10; i++) { }
        pragma assert(i == 1);
    }
}

@test(array_loop)
@run(test.test)
contract test {
    int64 a1[2] = new { 194, -228 };
    string a2[2][3] = new {
        { "hello", " ", "world" },
        { "this is", " ", "aergo" },
    };

    test() {
        int64 j;

        for (int64 i in a1) { j += i; }
        pragma assert(j == -34);

        int64 i;
        for (i in a1) { j++; }
        pragma assert(j == -32);

        int idx = 0;
        string v;
        for (string s1[3] in a2) {
            string s;
            for (string s2 in s1) {
                s += s2;
            }
            if (idx++ == 0) {
                pragma assert(s == "hello world");
                v += s + ", ";
            }
            else {
                pragma assert(s == "this is aergo");
                v += s;
            }
        }
        pragma assert(idx == 2);
        pragma assert(v == "hello world, this is aergo");
    }
}

@test(invalid_array_iterator_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int64 v[2] = new { 1, 2 };
    test() {
        for (int i in v) { }
    }
}

@test(invalid_array_iterator_count)
@error(ERROR_MISMATCHED_COUNT)
contract test {
    int v[2][2] = new { { 1, 2 }, { 3, 4 } };
    test() {
        for (int i[3] in v) { }
    }
}

@test(string_loop)
@run(test.test)
contract test {
    string x = "Game of Thrones";

    test() {
        int i;

        for (byte b in x) {
            pragma assert(b == x[i++]);
        }
        pragma assert(i == 15);
        pragma assert(x[8] == 'T');

        i = 0;
        string y = "Summers span decades.\n\tWinters can last a lifetime.";

        for (byte b in y) {
            pragma assert(b == y[i++]);
        }
        pragma assert(i == 51);
        pragma assert(y[21] == '\n');
        pragma assert(y[22] == '\t');
    }
}

@test(loop_jump)
@run(test.test)
contract test {
    test() {
        for { break; }

        int v;
        for (int i = 0; i < 10; i++) { continue; v += i; }
        pragma assert(v == 0);
    }
}

@test(jump_outside_loop)
@error(ERROR_INVALID_CONTINUE)
contract test {
    test() { continue; }
}

@test(goto_backward_label)
contract test {
    test() { here: goto here; }
}

@test(goto_forward_label)
contract test {
    test() { goto here; here: ; }
}

@test(goto_innermost_block)
contract test {
    test() { goto here; { here: ; } }
}

@test(duplicated_label)
@error(ERROR_DUPLICATED_ID)
contract test {
    test() { here: ; here: ; goto here; }
}

@test(undefined_label)
@error(ERROR_UNDEFINED_LABEL)
contract test {
    test() { goto nowhere; }
}

@test(return_void)
contract test {
    string s;
    test() {
        if (s == null) {
            return;
        }
        for (s == null) {
            return;
        }
        for (s = "start"; ; ) {
            return;
        }
        switch {
        case true:
            return;
        }
        return;
    }
}

@test(inline_ddl)
contract test {
    test() {
        create table t (c1 number);
        create table t (
            c1 number,
            c2 text
        );
        create index idx on t (c1);
        drop table t;
        create view v as select * from t;
    }
}

@test(invalid_ddl_object)
@error(ERROR_SYNTAX)
contract test {
    test() {
        create user person identified by person;
    }
}

@test(inline_dml)
contract test {
    test() {
        insert into emp values (10, 'Sam');
        int cnt = insert into emp values (20, 'Bill');

        delete from emp where id = 10;
        cnt = delete from emp where name = 'Bill';

        update emp set name = 'Tom' where c1 = 10;
    }
}

@test(inline_query)
contract test {
    int v1;
    string v2;
    test() {
        /*
        v1 = select id from emp;
        v1, v2 =
            select id,
                   name
              from emp;
              */
    }
}

@test(missing_sql_terminator)
@error(ERROR_SYNTAX)
contract test {
    int v1;
    test() {
        v1 = select id from emp
    }
}
