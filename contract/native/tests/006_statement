@test(assignment)
contract test {
    int i1, i2;

    test() {
        i1 = 1;
        i1, i2 = 1, 2;

        i1 += 1;
        i1 -= 1;
        i1 *= 1 + 1;
        i1 /= 2;
        i1 %= 10;

        i2 |= 0xff;
        i2 &= 0x01;
        i2 ^= 0x01;

        string s = "first";
        s += ", second";

        i1, s = 1, "first";
    }
}

@test(invalid_lvalue)
@error(ERROR_INVALID_LVALUE,4)
contract test {
    const int i = 0;
    int j, k;
    test() {
        1 = 1;
        i = 1;
        j + 1 = 1;
        i == 0 ? j : k = 1;
    }
}

@test(mismatched_tuple_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i;
    string s;
    test() {
        i, s = 1, 2;
    }
}

@test(array_assignment)
contract test {
    test() {
        int i[10];
        i[0] = 0;
        i[0] += 1;
        i[0]++;

        int idx = 1;
        i[idx] = i[0];
        i[idx]--;

        i[idx + 1] = i[0] + i[idx];
        i[idx + 2] = 7;

        int j[10];
        j = i;
    }
}

@test(mismatched_array_dimension)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    test() {
        int i[2][2];
        int j[2];
        j = i;
    }
}

@test(mismatched_array_size)
@error(ERROR_MISMATCHED_COUNT)
contract test {
    test() {
        int i[2];
        int j[1];
        j = i;
    }
}

@test(index_out_of_range)
@error(ERROR_INVALID_ARR_IDX)
contract test {
    test() {
        int i[2];
        i[1 + 1] = 1;
    }
}

@test(invalid_array_subscription)
@error(ERROR_INVALID_SUBSCRIPT)
contract test {
    test() {
        int i;
        i[0] = 1;
    }
}

@test(struct_assignment)
contract test {
    type s1 struct { int a, b; }
    test() {
        s1 v1, v2;
        v1 = v2;
        v2 = v1;
    }
}

@test(struct_array_assignment)
contract test {
    type s1 struct { int a, b; }
    test() {
        s1 v1[2][2];
        s1 v2[2][2];
        s1 v3[2];

        v1 = v2;
        v1[0] = v3;
        v1[1] = v3;
        v3[0] = v1[0][0];
    }
}

@test(map_assignment)
contract test {
    test() {
        map(int, string) m1;
        m1[1] = "1";
        m1[2] = "2";

        map(int, string) m2 = m1;

        type s struct {
            int a;
            string b;
        }
        s v1 = new { 1, "1" };
        s v2 = new { 2, "2" };

        map(string, s) m3;
        m3["1"] = v1;
        m3["2"] = v2;

        map(s, int) m4;
        m4[v1] = 1;
        m4[v2] = 2;
    }
}

@test(map_array_assignment)
contract test {
    test() {
        map(int, string) m1[2];
        map(int, string) m2[2];
        map(int, string) m3;

        m1 = m2;
        m1[0] = m3;
        m1[1] = m3;
        m3 = m2[0];
    }
}

@test(mismatched_map_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    test() {
        type s1 struct { int a; }
        type s2 struct { string a; }
        s2 v = new { "2" };

        map(int, s1) m;
        m[1] = v;
    }
}

@test(tuple_assignment)
contract test {
    string s3, s4;

    test() {
        int i1, i2 = 1, 2;
        (i1, i2) = 1 * 1, 2;

        s3, s4 = ("a", "b");
        s3, s4 = "a", "b";

        i1, s3 = 3, "c";
    }
}

@test(mismatched_tuple_count)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    test() {
        int i, j;
        i, j = 1;
    }
}

@test(struct_access)
contract test {
    type s struct {
        int a;
        string b;
        map(int, bool) c;
        double d[2];
    }
    test() {
        s v = new { 1, "1", { { 1, true } }, { 0.1, 0.2 } };
        v.a++;
        v.a |= 0xabcd;
        v.b += "2";
        v.a, v.b = 2, "2";
        v.c[1] = false;
        v.d[1] = -v.d[0];
    }
}

@test(enum_access)
contract test {
    enum e { a }
    test() {
        int32 i3 = e.a;
    }
}

@test(using_enum_as_lvalue)
@error(ERROR_INVALID_LVALUE)
contract test {
    enum e { a }
    test() {
        e.a = 3;
    }
}

@test(if_else)
contract test {
    int v1 = 1;
    string v2;

    test() {
        if (0 == 0) { }

        if (!true) {
            v2 = "this is if";
        }
        else {
            v2 = "this is else";
        }

        if (v1 == 1) {
            v2 = "first";
        } else if (v1 == 2 || v1 == 3) {
            v2 = "second";
        } else {
            v2 = "don't care";
        }
    }
}

@test(missing_if_parenthesis)
@error(ERROR_SYNTAX)
contract test {
    test() { if 1 == 1 { } }
}

@test(missing_if_brace)
@error(ERROR_SYNTAX)
contract test {
    test() { if (1 == 1); }
}

@test(non_boolean_if_condition)
@error(ERROR_INVALID_COND_TYPE)
contract test {
    test() { if (1) { } }
}

@test(switch_case)
contract test {
    int i;
    string s;

    test() {
        switch (i) {
        case 1: s = "case 1"; break;
        case 2: { s = "case 2"; } break;
        default: break;
        }
    }
}

@test(mismatched_case_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i;

    test() {
        switch (i) {
        case 1: break;
        case "2": break;
        }
    }
}

@test(duplicated_case_value)
@error(ERROR_DUPLICATED_VALUE)
contract test {
    int i;

    test() {
        switch (i) {
        case 1: break;
        case 1: i++;
        }
    }
}

@test(duplicated_default)
@error(ERROR_DUPLICATED_LABEL)
contract test {
    int i;

    test() {
        switch (i) {
        case 1: break;
        default: i++; break;
        default: i--; break;
        }
    }
}

@test(without_switch_variable)
contract test {
    int i;
    string s;

    test() {
        switch {
        case i == 1: { } break;
        case s == "second": break;
        }
    }
}

@test(duplicated_case_expression)
@error(ERROR_DUPLICATED_VALUE)
contract test {
    int i;
    string s;

    test() {
        switch {
        case i == 1: { } break;
        case i == 1: break;
        }
    }
}

@test(non_boolean_case_condition)
@error(ERROR_INVALID_COND_TYPE)
contract test {
    test() {
        switch {
        case 1 == 1: break;
        case 2: break;
        }
    }
}

@test(for_loop)
contract test {
    int v1;

    test() {
        int i;
        for (i = 0; i < 10; i++) { v1 += i; }
        for (i = 0; i < 10; ) { }
        for (i = 0; ; ) { }
        for ( ; i < 10; ) { }
        for ( ; i < 10; i++) { }
        for ( ; ; i++) { }
        for ( ; ; ) { }
        for (true) { }
        for { }

        for (int j = 1; j >= 0; i--) { }
        for (int j = i; j >= 0; ) { }
        for (int j = i; ; ) { }

        int j;
        for (i, j = 0, 5; i < 10 && j >= 0; i++, j--) { }
        // for (i, j = 0, 5; i < 10 && j >= 0; i++, j += 2) { }
    }
}

@test(iterator_scope)
contract test {
    test() {
        int i;
        for (int i = 0; i <= 10; i++) { }
    }
}

@test(array_loop)
contract test {
    string v1[10];

    test() {
        /*
        for (string s1 in v1) { }

        string s2;
        for (s2 in v1) { }
        */
    }
}

@test(loop_jump)
contract test {
    test() {
        for { break; }
        for (int i = 0; i < 10; i++) { continue; }
    }
}

@test(jump_outside_loop)
@error(ERROR_INVALID_JUMP_STMT)
contract test {
    test() { continue; }
}

@test(goto_backward_label)
contract test {
    test() { here: goto here; }
}

@test(goto_forward_label)
contract test {
    test() { goto here; here: ; }
}

@test(goto_innermost_block)
contract test {
    test() { goto here; { here: ; } }
}

@test(duplicated_label)
@error(ERROR_DUPLICATED_ID)
contract test {
    test() { here: ; here: ; goto here; }
}

@test(undefined_label)
@error(ERROR_UNDEFINED_LABEL)
contract test {
    test() { goto nowhere; }
}

@test(inline_ddl)
contract test {
    test() {
        create table t (c1 number);
        create table t (
            c1 number,
            c2 varchar(100)
        );
        create index idx on t (c1);
        drop table t;
    }
}

@test(invalid_ddl_object)
@error(ERROR_SYNTAX)
contract test {
    test() {
        create view v as select * from t;
    }
}

@test(inline_dml)
contract test {
    test() {
        insert into emp values (10, 'Sam');
        int cnt = insert into emp values (20, 'Bill');

        delete from emp where id = 10;
        cnt = delete from emp where name = 'Bill';

        update emp set name = 'Tom' where c1 = 10;
    }
}

@test(inline_query)
contract test {
    int v1;
    string v2;
    test() {
        /*
        v1 = select id from emp;
        v1, v2 =
            select id,
                   name
              from emp;
              */
    }
}

@test(missing_sql_terminator)
@error(ERROR_SYNTAX)
contract test {
    int v1;
    test() {
        v1 = select id from emp
    }
}
