@test(assignment)
contract test {
    int i1, i2;

    test() {
        i1 += 1;
        i1 -= 1;
        i1 *= 1 + 1;
        i1 /= 2;
        i1 %= 10;

        i2 |= 0xff;
        i2 &= 0x01;
        i2 ^= 0x01;

        string s = "first";
        s += ", second";
    }
}

@test(literal_lvalue)
@error(ERROR_INVALID_LVALUE)
contract test {
    test() {
        1 = 1;
    }
}

@test(constant_lvalue)
@error(ERROR_INVALID_LVALUE)
contract test {
    const int i = 0;
    test() {
        i = 1;
    }
}

@test(array_assignment)
contract test {
    test() {
        int i[10];
        i[0] = 0;
        i[0] += 1;
        i[0]++;

        int idx = 1;
        i[idx] = i[0];
        i[idx]--;

        i[idx + 1] = i[0] + i[idx];
        i[idx + 2] = 7;
    }
}

@test(map_assignment)
contract test {
    test() {
        map(int, string) m1;
        m1[1] = "1";
        m1[2] = "2";

        struct s {
            int a;
            string b;
        }
        s v1 = { 1, "1" };
        s v2 = { 2, "2" };

        map(string, s) m3;
        m3["1"] = v1;
        m3["2"] = v2;

        map(s, int) m4;
        m4[v1] = 1;
        m4[v2] = 2;
    }
}

@test(mismatched_map_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    test() {
        struct s1 {
            int a;
        }
        struct s2 {
            string a;
        }
        s2 v = { "2" };

        map(int, s1) m;
        m[1] = v;
    }
}

@test(tuple_assignment)
contract test {
    string s3, s4;

    test() {
        int i1, i2 = 1, 2;
        (i1, i2) = 1 * 1, 2;

        s3, s4 = ("a", "b");
        s3, s4 = "a", "b";

        i1, s3 = 3, "c";
    }
}

@test(mismatched_tuple_count)
@error(ERROR_MISMATCHED_ELEM_CNT)
contract test {
    test() {
        int i, j;
        i, j = 1;
    }
}

@test(struct_access)
contract test {
    struct s {
        int a;
        string b;
        map(int, bool) c;
        double d[2];
    }
    test() {
        s v = { 1, "1", { { 1, true } }, { 0.1, 0.2 } };
        v.a++;
        v.a |= 0xabcd;
        v.b += "2";
        v.a, v.b = 2, "2";
        v.c[1] = false;
        v.d[2] = -v.d[1];
    }
}

@test(enum_access)
contract test {
    enum e {
        a
    }
    test() {
        int32 i3 = e.a;
    }
}

@test(using_enum_as_lvalue)
@error(ERROR_INVALID_LVALUE)
contract test {
    enum e {
        a
    }
    test() {
        e.a = 3;
    }
}

@test(if_else)
contract test {
    int v1 = 1;
    string v2;

    test() {
        if (0 == 0) { }

        if (!true) {
            v2 = "this is if";
        }
        else {
            v2 = "this is else";
        }

        if (v1 == 1) {
            v2 = "first";
        } else if (v1 == 2 || v1 == 3) {
            v2 = "second";
        } else {
            v2 = "don't care";
        }
    }
}

@test(missing_if_parenthesis)
@error(ERROR_SYNTAX)
contract test {
    test() {
        if 1 == 1 { }
    }
}

@test(missing_if_brace)
@error(ERROR_SYNTAX)
contract test {
    test() {
        if (1 == 1);
    }
}

@test(non_boolean_if_condition)
@error(ERROR_INVALID_COND_TYPE)
contract test {
    test() {
        if (1) { }
    }
}

@test(switch_case)
contract test {
    int i;
    string s;

    test() {
        switch (i) {
        case 1:
            s = "case 1";
            break;
        case 2:
            { s = "case 2"; }
            break;
        default:
            break;
        }
    }
}

@test(mismatched_case_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i;

    test() {
        switch (i) {
        case 1: break;
        case "2": break;
        }
    }
}

@test(without_switch_variable)
contract test {
    int i;
    string s;

    test() {
        switch {
        case i == 1: { }
            break;
        case s == "second":
            break;
        }
    }
}

@test(non_boolean_case_condition)
@error(ERROR_INVALID_COND_TYPE)
contract test {
    test() {
        switch {
        case 1 == 1: break;
        case 2: break;
        }
    }
}

@test(for_loop)
contract test {
    int v1;

    test() {
        int i;
        for (i = 0; i < 10; i++) {
            v1 += i;
        }
        for (i = 0; i < 10; ) { }
        for (i = 0; ; ) { }
        for ( ; i < 10; ) { }
        for ( ; i < 10; i++) { }
        for ( ; ; i++) { }
        for ( ; ; ) { }
        for (true) { }
        for { }

        for (int j = 1; j >= 0; i--) { }
        for (int j = i; j >= 0; ) { }
        for (int j = i; ; ) { }

        int j;
        for (i, j = 0, 5; i < 10 && j >= 0; i++, j--) { }
        // for (i, j = 0, 5; i < 10 && j >= 0; i++, j += 2) { }
    }
}

@test(iterator_scope)
contract test {
    test() {
        int i;
        for (int i = 0; i <= 10; i++) { }
    }
}

@test(array_loop)
contract test {
    string v1[10];

    test() {
        /*
        for (string s1 in v1) { }

        string s2;
        for (s2 in v1) { }
        */
    }
}

@test(loop_jump)
contract test {
    test() {
        for {
            break;
        }
        for (int i = 0; i < 10; i++) {
            continue;
        }
    }
}

@test(jump_outside_loop)
@error(ERROR_INVALID_JUMP_STMT)
contract test {
    test() {
        continue;
    }
}

@test(goto_label)
contract test {
    test() {
here:
        goto here;
    }
}

@test(undefined_label)
@error(ERROR_UNDEFINED_LABEL)
contract test {
    test() {
        goto nowhere;
    }
}

@test(inline_ddl)
contract test {
    test() {
        create table t (c1 number);
        create table t (
            c1 number,
            c2 varchar(100)
        );
        create index idx on t (c1);
        drop table t;
    }
}

@test(invalid_ddl_object)
@error(ERROR_SYNTAX)
contract test {
    test() {
        create view v as select * from t;
    }
}

@test(inline_dml)
contract test {
    test() {
        insert into emp values (10, 'Sam');
        int cnt = insert into emp values (20, 'Bill');

        delete from emp where id = 10;
        cnt = delete from emp where name = 'Bill';

        update emp set name = 'Tom' where c1 = 10;
    }
}

@test(inline_query)
contract test {
    int v1;
    string v2;
    test() {
        /* 
        v1 = select id from emp;
        v1, v2 =
            select id,
                   name
              from emp;
              */
    }
}

@test(missing_sql_terminator)
@error(ERROR_SYNTAX)
contract test {
    int v1;
    test() {
        v1 = select id from emp
    }
}
