@test(arithmetic_operator)
@run(test.test)
contract test {
    int i1 = 2 + 3;
    int i2 = 1 - 0x80;
    int i3 = 8 * (9);
    int i4 = i3 / 3;
    int i5 = 33 % 12;
    int i6 = (i4 * 3) / (5 + 1) % 5;
    int i7 = i1 + i2;

    int256 z1 = 1;
    int256 z2 = z1 + 1;
    int256 z3 = z1 - 0x1;
    int256 z4 = z1 * (1);
    int256 z5 = z1 / 1;
    int256 z6 = z1 % 1;

    string s1 = "string" + "concat";
    string s2 = "string" + " " + "concat";
    string s3 = s1 + "->" + s2;

    test() {
        pragma assert(i1 == 5);
        pragma assert(i2 == -127);
        pragma assert(i3 == 72);
        pragma assert(i4 == 24);
        pragma assert(i5 == 9);
        pragma assert(i6 == 2);
        pragma assert(i7 == -122);

        pragma assert(z1 == 1);
        pragma assert(z2 == 2);
        pragma assert(z3 == 0);
        pragma assert(z4 == 1);
        pragma assert(z5 == 1);
        pragma assert(z6 == 0);

        pragma assert(s1 == "stringconcat");
        pragma assert(s2 == "string concat");
        pragma assert(s3 == "stringconcat->string concat");
    }
}

@test(arithmetic_overflow)
@run(test.test)
contract test {
    int8 i1 = 100;
    int8 i2 = i1 + 100;

    test() {
        pragma assert(i2 == -56);
    }
}

@test(mismatched_arithmetic_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    int i = 1;
    int64 j = i + 1;
}

@test(non_integer_arithmetic_type)
@error(ERROR_INVALID_OP_TYPE)
contract test {
    bool b = true + false;
}

@test(zero_divisor_in_modulo)
@error(ERROR_DIVIDE_BY_ZERO)
contract test {
    int i = 10 % 0;
}

@test(zero_divisor_in_division)
@error(ERROR_DIVIDE_BY_ZERO)
contract test {
    int i = 10 / 0;
}

@test(bitwise_operator)
@run(test.test)
contract test {
    int i1 = (0xab & 0xcd);
    int i2 = 0xff ^ 0x02;
    int i3 = i1 | i2 | 3;
    int i4 = ~0xffabc;
    int i5 = ~i3;
    int i6 = 1 + 1 << 1;
    int i7 = 0xff >> 1;
    int i8 = i7 >> i6;

    int256 z1 = 8;
    int256 z2 = 0x8012 & z1;
    int256 z3 = 0xaa34 | z1;
    int256 z4 = ~-105918;
    int256 z5 = ~z3;
    int256 z6 = 0xcd56 ^ z1;
    int256 z7 = z3 >> z1;
    int256 z8 = z6 << z1;

    test() {
        pragma assert(i1 == 137);
        pragma assert(i2 == 253);
        pragma assert(i3 == 255);
        pragma assert(i4 == -1047229);
        pragma assert(i5 == -256);
        pragma assert(i6 == 3);
        pragma assert(i7 == 127);
        pragma assert(i8 == 15);

        pragma assert(z1 == 8);
        pragma assert(z2 == 0);
        pragma assert(z3 == 43580);
        pragma assert(z4 == 105917);
        pragma assert(z5 == -43581);
        pragma assert(z6 == 52574);
        pragma assert(z7 == 170);
        pragma assert(z8 == 13458944);
    }
}

@test(negative_bitwise_operand)
@error(ERROR_INVALID_OP_TYPE)
contract test {
    int i = 1 << -1;
}

@test(non_integer_bitwise_operand)
//@error(ERROR_INVALID_OP_TYPE)
contract test {
    //int i = 1.1 & 1.0;
}

@test(comparison_operator)
@run(test.test)
contract test {
    bool b1 = 1 == 1;
    bool b2 = 1 != 1;
    bool b3 = 1 > 1;
    bool b4 = 1 < 1;
    bool b5 = 1 >= 1;
    bool b6 = 1 <= 1;
    bool b7 = (b6 == true);

    string s1 = "1";
    string s2 = "2";
    bool b8 = (s1 == "1");
    bool b9 = (s1 != s2);
    bool b10 = (s1 > s2);
    bool b11 = (s1 < s2);

    int256 z1 = 1;
    int256 z2 = 2;
    bool b12 = z1 == 1;
    bool b13 = z1 != 1;
    bool b14 = z1 < z2;
    bool b15 = z1 > z2;

    test() {
        pragma assert(b1 == true);
        pragma assert(b2 == false);
        pragma assert(b3 == false);
        pragma assert(b4 == false);
        pragma assert(b5 == true);
        pragma assert(b6 == true);
        pragma assert(b7 == true);

        pragma assert(b8 == true);
        pragma assert(b9 == true);
        pragma assert(b10 == false);
        pragma assert(b11 == true);

        pragma assert(b12 == true);
        pragma assert(b13 == false);
        pragma assert(b14 == true);
        pragma assert(b15 == false);
    }
}

@test(mismatched_comparison_type)
//@error(ERROR_MISMATCHED_TYPE)
contract test {
    //bool b = 1 == 1.0;
}

@test(comparison_with_map)
contract test {
    map(int, string) m;
    bool b1 = m == null;
}

@test(comparison_with_tuple)
@error(ERROR_INVALID_OP_TYPE)
contract test {
    int i, j, k, l = 1, 1, 1, 1;
    bool b1 = (i, j) == (k, l);
}

@test(logical_operator)
@run(test.test)
contract test {
    bool b1 = true && false;
    bool b2 = true || false;

    bool b3 = (true || false) && (true);
    bool b4 = b1 && b2;

    test() {
        pragma assert(b1 == false);
        pragma assert(b2 == true);
        pragma assert(b3 == true);
        pragma assert(b4 == false);
    }
}

@test(non_boolean_operand_type)
@error(ERROR_INVALID_COND_TYPE)
contract test {
    bool b = true && 0;
}

@test(unary_operator)
@run(test.test)
contract test {
    int i1 = 0;
    int i2 = i1++;
    int i3 = ++i1;
    int i4 = i1--;
    int i5 = --i1;
    int i6 = -i1;

    int256 z1 = 1;
    int256 z2 = z1++;
    int256 z3 = z1--;
    int256 z4 = -z1;

    bool b1 = true;
    bool b2 = !b1;

    test() {
        pragma assert(i1 == 0);
        pragma assert(i2 == 0);
        pragma assert(i3 == 2);
        pragma assert(i4 == 2);
        pragma assert(i5 == 0);
        pragma assert(i6 == 0);

        i1 = 1;
        i1++, i1++;
        pragma assert(i1 == 3);

        pragma assert(z1 == 1);
        pragma assert(z2 == 1);
        pragma assert(z3 == 2);
        pragma assert(z4 == -1);

        pragma assert(b1 == true);
        pragma assert(b2 == false);
    }
}

@test(constant_unary_operand)
@error(ERROR_INVALID_LVALUE)
contract test {
    const int i = 0;
    int j = i++;
}

@test(non_integer_unary_operand)
@error(ERROR_INVALID_OP_TYPE)
contract test {
    string s = "1";
    int i = s++;
}

@test(ternary_operator)
@run(test.test)
contract test {
    int i1 = true ? 1 : 0;
    int i2 = false ? 1 : false ? 2 : 0;
    int i3 = (1 == 1) ? 1 + 1 : 0;

    test() {
        pragma assert(i1 == 1);
        pragma assert(i2 == 0);
        pragma assert(i3 == 2);
    }
}

@test(non_boolean_prefix_type)
@error(ERROR_INVALID_COND_TYPE)
contract test {
    string s = 1 ? "true" : "false";
}

@test(mismatched_infix_postfix_type)
@error(ERROR_MISMATCHED_TYPE)
contract test {
    string s = 1 == 1 ? "true" : false;
}

@test(typecast_from_constant)
@run(test.test)
contract test {
    bool b1 = (bool)false;

    int16 i1 = (int16)8;
    int16 i2 = (int16)"-945";

    string s1 = (string)"self";
    string s2 = (string)124;

    test() {
        pragma assert(b1 == false);

        pragma assert(i1 == 8);
        pragma assert(i2 == -945);

        pragma assert(s1 == "self");
        pragma assert(s2 == "124");
    }
}

@test(typecast_to_bool)
@error(ERROR_INCOMPATIBLE_TYPE,6)
contract test {
    byte b1 = 0;
    int8 i1 = -1;
    int16 i2 = 0;
    int64 i3 = 1;
    int256 i4 = 2;
    string s = "false";

    bool v1 = (bool)b1;
    bool v2 = (bool)i1;
    bool v3 = (bool)i2;
    bool v4 = (bool)i3;
    bool v5 = (bool)i4;
    bool v8 = (bool)s;
}

@test(typecast_to_int8)
@run(test.test)
contract test {
    byte b1 = 255;
    int16 i1 = 127;
    int64 i2 = -128;
    int256 i3 = 0;
    string s = "17";

    int8 v1 = (int8)b1;
    int8 v2 = (int8)i1;
    int8 v3 = (int8)i2;
    int8 v4 = (int8)i3;
    int8 v5 = (int8)s;

    test() {
        pragma assert(v1 == -1);
        pragma assert(v2 == 127);
        pragma assert(v3 == -128);
        pragma assert(v4 == 0);
        pragma assert(v5 == 17);
    }
}

@test(typecast_to_int16)
@run(test.test)
contract test {
    byte b1 = 58;
    int8 i1 = -2;
    int64 i2 = 0xf000;
    int256 i3 = 0x1234;
    string s = "32000";

    int16 v1 = (int16)b1;
    int16 v2 = (int16)i1;
    int16 v3 = (int16)i2;
    int16 v4 = (int16)i3;
    int16 v5 = (int16)s;

    test() {
        pragma assert(v1 == 58);
        pragma assert(v2 == -2);
        pragma assert(v3 == -4096);
        pragma assert(v4 == 4660);
        pragma assert(v5 == 32000);
    }
}

@test(typecast_to_int64)
@run(test.test)
contract test {
    byte b1 = 0;
    int8 i1 = 100;
    int16 i2 = 32760;
    int256 i3 = 0x8000000000000000;
    string s = "3.141592";

    int64 v1 = (int64)b1;
    int64 v2 = (int64)i1;
    int64 v3 = (int64)i2;
    int64 v4 = (int64)i3;
    int64 v5 = (int64)s;

    test() {
        pragma assert(v1 == 0);
        pragma assert(v2 == 100);
        pragma assert(v3 == 32760);
        pragma assert(v4 == -9223372036854775808);
        pragma assert(v5 == 3);
    }
}

@test(typecast_to_int256)
contract test {
    byte b1 = 196;
    int8 i1 = -23;
    int16 i2 = 14452;
    int64 i3 = -50000000000000;
    string s = "2019";

    int256 v1 = (int256)b1;
    int256 v2 = (int256)i1;
    int256 v3 = (int256)i2;
    int256 v4 = (int256)i3;
    int256 v5 = (int256)s;

    test() {
        pragma assert(v1 == 196);
        pragma assert(v2 == -23);
        pragma assert(v3 == 14452);
        pragma assert(v4 == -50000000000000);
        pragma assert(v5 == 2019);
    }
}

@test(typecast_to_string)
contract test {
    bool b1 = true;
    byte b2 = 65;
    int8 i1 = 118;
    int16 i2 = -32000;
    int64 i3 = 9000000000000000000;
    int256 i4 = -170000000000000000000000000000000000000;

    string v1 = (string)b1;
    string v2 = (string)b2;
    string v3 = (string)i1;
    string v4 = (string)i2;
    string v5 = (string)i3;
    string v6 = (string)i4;

    test() {
        pragma assert(v1 == "true");
        pragma assert(v2 == "A");
        pragma assert(v3 == "118");
        pragma assert(v4 == "-32000");
        pragma assert(v5 == "9000000000000000000");
        pragma assert(v6 == "-170000000000000000000000000000000000000");
    }
}
