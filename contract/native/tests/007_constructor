@test(empty_constructor)
contract test {
    test() { }
}

@test(constructor_with_arguments)
contract test1 {
    test1(int x) { }
}
contract test2 {
    test2(int x, map(int, string) y) { }
}

@test(missing_construtor)
@error(ERROR_MISMATCHED_NAME)
contract test {
    test2() { }
}

@test(return_parameter_declaration)
@error(ERROR_SYNTAX)
contract test {
    test(int x) byte { }
}

@test(multiple_constructor)
@error(ERROR_MISMATCHED_NAME)
contract test {
    test(int x) { }
    test2(int x, string y) { }
}

@test(duplicated_constructor)
@error(ERROR_DUPLICATED_ID)
contract test {
    test(int x) { }
    test(int x, string y) { }
}

@test(instantiate)
contract callee {
}
contract test {
    callee c1 = new callee();
    test() {
        callee c2 = c1;
        callee c3 = new callee();
    }
}

@test(instantiate_with_array)
contract callee {
}
contract test {
    callee c1[] = new callee[2];
    test() {
        c1[0] = new callee();
        c1[1] = new callee();

        callee c2[] = new callee[2];
        c2[0] = c1[0];
        c2[1] = c1[1];
    }
}

@test(instantiate_without_lvalue)
contract callee {
}
contract test {
    test() { new callee(); }
}

@test(instantiate_with_non_constructor)
@error(ERROR_UNDEFINED_ID)
contract test {
    test() {
        test c = new f();
    }
    func f() test { return null; }
}

@test(missing_parenthesis)
@error(ERROR_NOT_ALLOWED_ALLOC)
contract callee { }

contract test {
    test() {
        callee c = new callee;
    }
}

@test(not_allowed_initializer)
@error(ERROR_MISMATCHED_TYPE)
contract callee { int a; }

contract test {
    test() {
        callee c = new { 1 };
    }
}

@test(mismatched_constructor)
@error(ERROR_MISMATCHED_TYPE)
contract callee { int a; }

contract test {
    test() {
        test c = new callee();
    }
}

@test(compare_with_instance)
contract callee { }

contract test {
    test() {
        callee c;
        if (c == null) { }
    }
}

@test(self_accessor)
@run(test.test)
contract test {
    int8 x;
    string y;
    func f(int8 x, string y) {
        this.x = x;
        this.y = y;
    }
    test() {
        this.x = 9;
        pragma assert(this.x == 9);

        this.y = "self";
        pragma assert(this.y == "self");

        f(10, "reference");
        pragma assert(this.x == 10);
        pragma assert(this.y == "reference");
    }
}

@test(self_accessor_as_parameter)
contract test {
    test() {
        f(this);
    }
    func f (test p) { }
}

@test(self_accessor_as_lvalue)
@error(ERROR_INVALID_LVALUE)
contract test {
    test() {
        this = new test();
    }
}

@test(self_accessor_as_return)
contract test {
    func f1() test { return this; }
}
